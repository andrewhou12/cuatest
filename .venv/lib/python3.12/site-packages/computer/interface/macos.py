import asyncio
import websockets
import json
import logging
import socket
import time
from typing import Optional, Dict, Any, Tuple, List, TypedDict
from .base import BaseComputerInterface
import tempfile
import subprocess
import os

logger = logging.getLogger(__name__)

class AccessibilityWindow(TypedDict):
    app_name: str
    pid: int
    frontmost: bool
    has_windows: bool
    windows: List[Dict[str, Any]]

class AccessibilityTree(TypedDict):
    success: bool
    frontmost_application: str
    windows: List[AccessibilityWindow]

class MacOSComputerInterface(BaseComputerInterface):
    """macOS-specific implementation of the computer interface."""

    def __init__(self, ip_address: str, username: str = "lume", password: str = "lume"):
        super().__init__(ip_address, username, password)
        self.ws_uri = f"ws://{ip_address}:8000/ws"
        self._ws = None
        self._reconnect_task = None
        self._closed = False

    async def _keep_alive(self):
        """Keep the WebSocket connection alive with automatic reconnection."""
        while not self._closed:
            try:
                if self._ws is None or self._ws.closed:
                    self._ws = await websockets.connect(
                        self.ws_uri,
                        max_size=1024 * 1024 * 10,  # 10MB limit
                        max_queue=32
                    )
                    logger.info("WebSocket connection established")
                
                await asyncio.sleep(30)
                if self._ws and not self._ws.closed:
                    try:
                        pong = await self._ws.ping()
                        await asyncio.wait_for(pong, timeout=10)
                    except:
                        await self._ws.close()
                        self._ws = None
                        
            except Exception as e:
                logger.error(f"WebSocket connection error: {e}")
                if self._ws:
                    await self._ws.close()
                self._ws = None
                await asyncio.sleep(5)

    async def _ensure_connection(self):
        """Ensure WebSocket connection is established."""
        if self._reconnect_task is None:
            self._reconnect_task = asyncio.create_task(self._keep_alive())
        
        retry_count = 0
        while self._ws is None or self._ws.closed:
            if retry_count >= 10:
                raise ConnectionError("Failed to establish WebSocket connection")
            await asyncio.sleep(0.5)
            retry_count += 1

    async def _send_command(self, command: str, params: Optional[Dict] = None) -> Dict[str, Any]:
        """Send command through WebSocket."""
        await self._ensure_connection()
        message = {
            "command": command,
            "params": params or {}
        }
        await self._ws.send(json.dumps(message))
        response = await self._ws.recv()
        return json.loads(response)

    async def wait_for_ready(self, timeout: int = 60, interval: float = 1.0):
        """Wait for WebSocket connection to become available."""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                if self._reconnect_task is None:
                    self._reconnect_task = asyncio.create_task(self._keep_alive())
                await self._ensure_connection()
                return
            except Exception:
                await asyncio.sleep(interval)
                continue
        raise TimeoutError(f"Could not connect to {self.ip_address} after {timeout} seconds")

    def close(self):
        """Close WebSocket connection."""
        self._closed = True
        if self._reconnect_task:
            self._reconnect_task.cancel()
        if self._ws:
            asyncio.create_task(self._ws.close())
            self._ws = None

    # Mouse Actions
    async def left_click(self, x: Optional[int] = None, y: Optional[int] = None) -> None:
        await self._send_command("left_click", {"x": x, "y": y})

    async def right_click(self, x: Optional[int] = None, y: Optional[int] = None) -> None:
        await self._send_command("right_click", {"x": x, "y": y})

    async def double_click(self, x: Optional[int] = None, y: Optional[int] = None) -> None:
        await self._send_command("double_click", {"x": x, "y": y})

    async def move_cursor(self, x: int, y: int) -> None:
        await self._send_command("move_cursor", {"x": x, "y": y})

    async def drag_to(self, x: int, y: int, button: str = "left", duration: float = 0.5) -> None:
        await self._send_command("drag_to", {"x": x, "y": y, "button": button, "duration": duration})

    # Keyboard Actions
    async def type(self, text: str) -> None:
        await self._send_command("type_text", {"text": text})

    async def press_key(self, key: str) -> None:
        await self._send_command("press_key", {"key": key})

    async def hotkey(self, *keys: str) -> None:
        await self._send_command("hotkey", {"keys": list(keys)})

    # Scrolling Actions
    async def scroll_down(self, clicks: int = 1) -> None:
        await self._send_command("scroll", {"direction": "down", "clicks": clicks})

    async def scroll_up(self, clicks: int = 1) -> None:
        await self._send_command("scroll", {"direction": "up", "clicks": clicks})

    # Screen Actions
    async def screenshot(self) -> bytes:
        result = await self._send_command("screenshot")
        if result.get('image_data'):
            import base64
            return base64.b64decode(result['image_data'])
        raise RuntimeError("Failed to take screenshot")

    async def get_screen_size(self) -> Dict[str, int]:
        result = await self._send_command("get_screen_size")
        if result['success'] and result['size']:
            return result['size']
        raise RuntimeError("Failed to get screen size")

    async def get_cursor_position(self) -> Dict[str, int]:
        result = await self._send_command("get_cursor_position")
        if result['success'] and result['position']:
            return result['position']
        raise RuntimeError("Failed to get cursor position")

    # Clipboard Actions
    async def copy_to_clipboard(self) -> str:
        result = await self._send_command("copy_to_clipboard")
        if result['success'] and result['content']:
            return result['content']
        raise RuntimeError("Failed to get clipboard content")

    async def set_clipboard(self, text: str) -> None:
        await self._send_command("set_clipboard", {"text": text})

    # File System Actions
    async def file_exists(self, path: str) -> bool:
        result = await self._send_command("file_exists", {"path": path})
        return result.get('exists', False)

    async def directory_exists(self, path: str) -> bool:
        result = await self._send_command("directory_exists", {"path": path})
        return result.get('exists', False)

    async def run_command(self, command: str) -> Tuple[str, str]:
        result = await self._send_command("run_command", {"command": command})
        if not result.get('success', False):
            raise RuntimeError(result.get('error', 'Failed to run command'))
        return result.get('stdout', ''), result.get('stderr', '')

    # Accessibility Actions
    async def get_accessibility_tree(self) -> AccessibilityTree:
        """Get accessibility tree."""
        result = await self._send_command("get_accessibility_tree")
        if not result.get('success', False):
            raise RuntimeError(result.get('error', 'Failed to get accessibility tree'))
        return result

    async def find_element_by_criteria(self, 
                                     role: Optional[str] = None, 
                                     title: Optional[str] = None,
                                     value: Optional[str] = None) -> Optional[Dict]:
        """Find element by accessibility criteria."""
        result = await self._send_command("find_element", {
            "role": role,
            "title": title,
            "value": value
        })
        if not result.get('success', False):
            raise RuntimeError(result.get('error', 'Failed to find element'))
        return result.get('element') 